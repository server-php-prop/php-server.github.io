<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <script src="https://unpkg.com/tesseract.js@5.0.3/dist/tesseract.min.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; 
        }
        #T {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 10px;
            border: none;
            box-sizing: border-box;
            font-family: monospace;
            font-size: 16px;
            resize: none; 
        }
    </style>
</head>
<body>
    <textarea id="T"></textarea>
    <script>
        // --- НАСТРОЙКИ ---
        const API_URL = "https://gm-z0j6.onrender.com/"; 
        
        // **Полный промпт-префикс**, который формируется на клиенте
        const PROMPT_PREFIX = `Role: ICPC Programmer.Task: Solve this problem in C++.Requirements:1. Use #include <bits/stdc++.h>2. Use using namespace std;3. Use typedef long long ll; and #define int long long.4. Optimize I/O: ios_base::sync_with_stdio(0); cin.tie(0);5. Short variable names (n, m, a, b).6. **STRICTLY NO COMMENTS OR EXPLANATIONS.** ONLY CODE.7. Use signed main8. Don't use return 0 at the end of the code9. use #define endl '\\n'Problem:`;
        // --- НАСТРОЙКИ ---
        
        const T = document.getElementById('T');
        
        if (T) {
            let isLoading = false; 
            
            T.addEventListener('paste', async (e) => {
                if (isLoading) {
                    e.preventDefault();
                    return;
                }
                
                e.preventDefault();
                isLoading = true;
                
                const clipboardData = e.clipboardData || window.clipboardData;
                let imageFile = null;
                let pastedText = "";

                if (clipboardData && clipboardData.items) {
                    for (let i = 0; i < clipboardData.items.length; i++) {
                        const item = clipboardData.items[i];
                        if (item.kind === 'file' && item.type.indexOf('image') !== -1) {
                            imageFile = item.getAsFile();
                        } else if (item.kind === 'string' && item.type.indexOf('text/plain') !== -1) {
                            pastedText = clipboardData.getData('text/plain');
                        }
                    }
                }

                let contentForGemini = null; // Будет содержать распознанный или вставленный текст
                
                T.value = ""; 
                T.style.color = "gray";
                T.disabled = true;

                if (imageFile) {
                    // 1. OCR для изображения
                    try {
                        T.value = "Идет распознавание текста с изображения...";
                        
                        const { data: { text } } = await Tesseract.recognize(
                            imageFile,
                            'eng+rus', 
                            { logger: m => {} } 
                        );
                        
                        contentForGemini = text;
                        
                    } catch (error) {
                        console.error("OCR Error:", error);
                        T.value = `ERROR: Распознавание не удалось. ${error.message}`;
                        T.style.color = "red";
                        isLoading = false;
                        T.disabled = false;
                        T.focus(); 
                        return;
                    }
                } else if (pastedText) {
                    // 2. Использование простого текста
                    contentForGemini = pastedText;
                } else {
                    isLoading = false;
                    T.disabled = false;
                    T.focus(); 
                    return;
                }

                // 3. Формирование **полного, готового промпта**
                T.value = ""; 
                const prompt = PROMPT_PREFIX + contentForGemini;
                
                // === ОСНОВНОЙ ВЫЗОВ API ===
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        // Отправляем **готовый** промпт в поле inputs
                        body: JSON.stringify({ inputs: prompt }) 
                    });
        
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
        
                    const data = await response.json();                        
                    let resultText = "";                        
        
                    if (data.candidates && data.candidates[0]?.content?.parts?.[0]?.text) {
                        resultText = data.candidates[0].content.parts[0].text;
                    } else if (data.generated_text) {
                        resultText = data.generated_text;
                    } else if (data.error) {
                        throw new Error(`API Error: ${JSON.stringify(data.error)}`);
                    } else {
                        throw new Error("Empty response");
                    }
        
                    resultText = resultText.replace(/^```[a-z]*\s*/i, '').replace(/```$/gm, '').trim();
        
                    T.value = resultText;
                    T.style.color = "black";
        
                } catch (error) {
                    T.value = `ERROR: ${error.message}`;
                    T.style.color = "red";
                } finally {
                    isLoading = false;
                    T.disabled = false;
                    T.focus(); 
                }
            });
        }
    </script>
</body>
</html>
